#### **=== GIT ===**

**Робоче середовище**

Ви завершили роботу над завданням для клієнта і у вас є робочий код, який був створений без використання git. Клієнт створив порожній репозиторій git@example.com:example/test.git і надав доступ для вас.
**Завдання**

Опишіть ваші подальші дії, щоб ваш код з'явився в гілці master у репозиторії git@example.com:example/test.git.

#### **=== CSS, HTML ===**

**Завдання**

1\. Створіть такий макет, використовуючи **Flexbox**

2\. Створіть такий макет, використовуючи **CSS Grid**

<https://cloud.devit-team.com/s/z9BbyZbeSR97Bfg>

3\. Створіть анімацію "Квадрат по центру вікна, обертається навколо своєї осі і змінює колір з червоного на оранжевий, а потім на зелений"
#### **=== JS логіка ===**

Буде плюсом реалізація на TypeScript. Максимально описуйте код коментарями.

**Завдання**

1\. Напишіть функцію deepEqual для перевірки двох об'єктів на ідентичність. Приклад:

```
deepEqual({name: 'test'}, {name: 'test'}) // output true
deepEqual({name: 'test'}, {name: 'test1'}) // output false
deepEqual({name: 'test', data: {value: 1}}, {name: 'test', data: {value: 2}}) // output false
deepEqual({name: 'test'}, {name: 'test', age: 10}) // false
```

2\. Напишіть функцію-генератор chunkArray, яка повертає ітератор, що повертає частини масиву заданої довжини.

Приклад:

```
const iterator = chunkArray([1,2,3,4,5,6,7,8], 3);
iterator.next() // { value: [1,2,3], done: false }
iterator.next() // { value: [4,5,6], done: false }
iterator.next() // { value: [7,8], done: false }
iterator.next() // { value: undefined, done: true }
```

3\. Напишіть функцію-обгортку, яка приймає на вхід масив функцій і їх параметрів і повертає масив результатів їх виконання. Кількість аргументів виконуваної функції **не обмежена**!


Приклад:

```
const f1 = (cb) => {cb(1)}
const f2 = (a, cb) => {cb(a)}
const f3 = (a, b, cb) => {setTimeout(() => cb([a, b]), 1000)}

bulkRun(
  [
    [f1, []],
    [f2, [2]]
    [f3, [3, 4]]
  ]
).then(console.log)
 // Output: [1, 2, [3, 4]]
```

4\. Напишіть метод arrayToObject, який перетворює масив в об'єкт (використовуйте рекурсію). Приклад:

```
var arr = [['name', 'developer'], ['age', 5], ['skills', [['html',4], ['css', 5], ['js',5]]]];

arrayToObject(arr)
// Outputs: {
	name: 'developer',
	age: 5,
	skills: {
		html: 4,
		css: 5,
		js: 5
	}
```

5\. Напишіть обернену функцію (див. завдання 4) objectToArray, яка з об'єкта створює масив. Приклад:

```
objectToArray({
	name: 'developer',
	age: 5,
	skills: {
		html: 4,
		css: 5,
		js: 5
	}
})

// Outputs: [['name', 'developer'], ['age', 5], ['skills', [['html', 4], ['css', 5], ['js', 5]]]
```

6\. Є функція `primitiveMultiply`, яка перемножує числа, але випадковим чином може викидати винятки типу `NotificationException`, `ErrorException`. Задача - написати функцію-обгортку, яка буде повторювати обчислення при винятку `NotificationException`, але припинятиме роботу при винятках `ErrorException`.

Приклад:

```
function NotificationException() {}
function ErrorException() {}
function primitiveMultiply(a, b) {
  const rand = Math.random();
  if (rand < 0.5) {
    return a * b;
  } else if(rand > 0.85) {
    throw new ErrorException()
  } else {
    throw new NotificationException()
  }
}

function reliableMultiply(a, b) {
  // Ваш код
}

console.log(reliableMultiply(8, 8));
```

7\.  Напишіть функцію, яка приймає об'єкт будь-якої вкладеності і перетворює його в єдину плоску карту з різними рівнями, розділеними косою рискою ('`/`').

Приклад:

```
const obj = {
  a: {
    b: {
      c: 12,
      d: 'Hello World'
    },
    e: [1,2,3]
  }
};

mapObject(demoData);
// Outputs: {
  'a/b/c': 12,
  'a/b/d': 'Hello World',
  'a/e': [1,2,3]
}
```

8\. Напишіть функцію `combos`, яка приймає позитивне ціле число `num` і повертає масив масивів позитивних цілих чисел, де сума кожного масиву дорівнює `num`. Масиви не повинні повторюватися.

Приклад:

```
combos(3);
// Output: 
[
  [ 3 ],
  [ 1, 1, 1 ],
  [ 1, 2 ] 
]

combos(10); 
// Output: 
[ 
  [ 10 ],
  [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
  [ 1, 1, 1, 1, 1, 1, 1, 1, 2 ],
  [ 1, 1, 1, 1, 1, 1, 1, 3 ],
  [ 1, 1, 1, 1, 1, 1, 4 ],
  [ 1, 1, 1, 1, 1, 5 ],
  [ 1, 1, 1, 1, 6 ],
  [ 1, 1, 1, 7 ],
  [ 1, 1, 8 ],
  [ 1, 9 ],
  [ 1, 1, 1, 1, 1, 1, 2, 2 ],
  [ 1, 1, 1, 1, 1, 2, 3 ],
  [ 1, 1, 1, 1, 2, 4 ],
  [ 1, 1, 1, 1, 2, 2, 2 ],
  [ 1, 1, 1, 1, 3, 3 ],
  [ 1, 1, 1, 2, 5 ],
  [ 1, 1, 1, 2, 2, 3 ],
  [ 1, 1, 1, 3, 4 ],
  [ 1, 1, 2, 6 ],
  [ 1, 1, 2, 2, 4 ],
  [ 1, 1, 2, 2, 2, 2 ],
  [ 1, 1, 2, 3, 3 ],
  [ 1, 1, 3, 5 ],
  [ 1, 1, 4, 4 ],
  [ 1, 2, 7 ],
  [ 1, 2, 2, 5 ],
  [ 1, 2, 2, 2, 3 ],
  [ 1, 2, 3, 4 ],
  [ 1, 3, 6 ],
  [ 1, 3, 3, 3 ],
  [ 1, 4, 5 ],
  [ 2, 8 ],
  [ 2, 2, 6 ],
  [ 2, 2, 2, 4 ],
  [ 2, 2, 2, 2, 2 ],
  [ 2, 2, 3, 3 ],
  [ 2, 3, 5 ],
  [ 2, 4, 4 ],
  [ 3, 7 ],
  [ 3, 3, 4 ],
  [ 4, 6 ],
  [ 5, 5 ]
]
```

9\.  Напишіть функцію `add`, яка працюватиме наступним чином: `add(1)(2)(7)...(n)`. Кількість послідовних викликів необмежена.

Пример:

```
Number(add(1)(2)); // == 3
Number(add(1)(2)(5)); // == 8
Number(add(1)(2)(-3)(4)); //  == 4
Number(add(1)(2)(3)(4)(-5)); // == 5
```
